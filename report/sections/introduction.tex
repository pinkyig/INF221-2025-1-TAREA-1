El presente informe se enmarca en el campo del Análisis y Diseño de Algoritmos en Ciencias de la Computación, destacando la importancia de evaluar la eficiencia y complejidad de diferentes métodos en contextos reales \cite{GoodScientificPaper}. Con ello se busca contextualizar el problema y establecer los antecedentes necesarios para comprender la relevancia de comparar técnicas que, si bien cuentan con fundamentos teóricos sólidos, presentan comportamientos distintos en la práctica, ya que factores como el acceso a memoria y las características del hardware pueden influir significativamente en su rendimiento.\\

A pesar del amplio conocimiento que existe sobre algoritmos de ordenamiento y multiplicación de matrices, persiste la necesidad de evaluar comparativamente técnicas de distinto coste computacional bajo condiciones experimentales controladas.En este trabajo concretamente se evaluaran experimentalmente dos grupos de algoritmos:
\begin{itemize} \item \textbf{Algoritmos de Ordenamiento:} Selection Sort, Mergesort y Quicksort.
\item \textbf{Algoritmos de Multiplicación de Matrices:} Naive y Strassen. \end{itemize}

Se conoce que \textbf{SelectionSort} opera con una complejidad $O(n^2)$, lo que lo hace ineficiente para grandes volúmenes de datos. Por otro lado, \textbf{Mergesort} ofrece una complejidad de 
$O(nlogn)$ a costa de una mayor complejidad en su implementación,y \textbf{Quicksort}, aunque generalmente resulta muy eficiente con una complejidad promedio de $O(nlogn)$, puede presentar una complejidad de $O(n^2)$ en su peor caso debido a una mala elección del pivote. En lo que respecta a la multiplicación de matrices, el método tradicional (Naive) tiene una complejidad de
$O(n^3)$, mientras el algoritmo de Strassen reduce la complejidad teórica a aproximadamente
$O(n^{2.81}).$\\

El propósito de este informe es realizar una evaluación experimental de los cinco algoritmos, midiendo su tiempo de ejecución en diversos escenarios de datos: aleatorios, parcialmente ordenados y en el caso de matrices, de tamaños crecientes. Para ello, se implementaron manualmente todos los algoritmos en C++ y se utilizó la biblioteca \texttt{<chrono>} para obtener mediciones precisas de los tiempos de ejecucion de cada algoritmo. De este modo, se busca identificar las diferencias entre la complejidad teórica y el desempeño real, así como destacar las ventajas y limitaciones de cada enfoque.